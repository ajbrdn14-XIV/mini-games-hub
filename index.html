<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Games Hub</title>
<meta name="description" content="Play fun mini games including a challenging maze and memory match!" />
<meta name="keywords" content="mini games, maze, memory game, puzzle, fun games" />
<meta name="author" content="Your Name" />
<style>
  :root{
    --gold:#d4af37; --red:#8b0000; --cream:#fff8f0; --shadow:0 8px 22px rgba(0,0,0,.16);
    --radius:16px; --gap:12px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:20px; min-height:100vh;
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;
    background:linear-gradient(135deg, ivory,var(--red));
    color:#2c2c2c; display:flex; flex-direction:column; align-items:center; text-align:center;
    overflow-x:hidden;
  }
  h1{font-size:clamp(1.8rem,2.6rem,3rem); margin:8px 0 2px; color:var(--red); animation:fadeIn .9s ease;}
  #subtitle{margin:0 0 12px; opacity:.85; font-size:.95rem}
  @keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:none}}

  /* === Overlays === */
  #tapOverlay, #introVideoOverlay{
    position:fixed; inset:0; background:#000; display:flex; align-items:center; justify-content:center;
    z-index:9999; flex-direction:column; color:white; font-size:1.2rem; text-align:center;
  }
  #tapOverlay button{
    margin-top:20px; padding:12px 24px; border:none; border-radius:var(--radius);
    background:var(--gold); color:white; font-weight:bold; cursor:pointer; box-shadow:var(--shadow); font-size:1rem;
  }
  #introVideoOverlay video{
    max-width:100%; max-height:100%; object-fit:contain;
  }
  .fade-out{ opacity:0; transition:opacity 1s ease; pointer-events:none; }

  .row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
  .btn{appearance:none;border:none;border-radius:var(--radius);background:var(--gold);color:#fff;padding:12px 18px;font-weight:700;cursor:pointer;box-shadow:var(--shadow);transition:transform .12s,filter .15s}
  .btn:hover{transform:translateY(-2px)}
  .panel{background:rgba(255,255,255,.66);border:2px solid var(--gold);border-radius:var(--radius);padding:14px;box-shadow:var(--shadow)}
  .game-container{display:none;width:min(96vw,960px);margin-top:12px}
  .title{margin:4px 0 10px;font-weight:800;color:var(--red)}

  /* Memory board (5 pairs = 10 cards) */
  #memoryBoard{display:grid;grid-template-columns:repeat(5,min(16vw,120px));gap:var(--gap);place-content:center}
  .card{width:min(16vw,120px);height:min(16vw,120px);display:flex;align-items:center;justify-content:center;
        font-size:clamp(1.6rem,7vw,2.4rem);background:var(--cream);border:2px solid var(--gold);border-radius:14px;cursor:pointer;user-select:none;box-shadow:0 6px 12px rgba(0,0,0,.08); transition:transform .12s}
  .card.hidden{color:transparent}
  .card.revealed{transform:scale(1.03)}

  /* Maze */
  #mazeWrap{position:relative;display:grid;place-items:center}
  canvas#mazeCanvas{width:min(92vmin,720px);height:min(92vmin,720px);border:3px solid var(--gold);border-radius:12px;background:#fff;touch-action:none}
  #mazeControls{margin-top:10px}

  /* D-Pad for mobile */
  #pad{position:fixed;right:16px;bottom:16px;display:grid;grid-template-columns:64px 64px 64px;grid-template-rows:64px 64px 64px;gap:8px;opacity:.88;z-index:30}
  .padBtn{background:rgba(0,0,0,.35);color:#fff;border:2px solid rgba(255,255,255,.45);border-radius:16px;font-size:1.25rem;display:grid;place-items:center;backdrop-filter:blur(6px);box-shadow:0 6px 14px rgba(0,0,0,.25)}
  .padBtn.blank{visibility:hidden}

  /* Hearts (fun background) */
  .heart{position:fixed;bottom:-50px;font-size:1.6rem;color:var(--gold);opacity:.85;animation:floatUp 7s linear infinite;pointer-events:none}
  @keyframes floatUp{0%{transform:translateY(0) scale(1);opacity:1}100%{transform:translateY(-105vh) scale(1.4);opacity:0}}

  /* Congrats modal */
  .modal{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.35);z-index:100}
  .modal.show{display:grid;animation:fadeIn .25s}
  .modalCard{background:#fff;border:3px solid var(--gold);border-radius:20px;padding:18px;width:min(92vw,460px);box-shadow:var(--shadow);text-align:center}
  .modalEmoji{font-size:2.2rem}
  .modalTitle{margin:8px 0 6px;color:var(--red);font-weight:800;font-size:1.4rem;animation:pop .6s}
  .modalMsg{margin:0 0 12px}
  @keyframes pop{0%{transform:scale(.6);opacity:0}60%{transform:scale(1.08)}100%{transform:scale(1);opacity:1}}

  @media(max-width:640px){
    #memoryBoard{grid-template-columns:repeat(4,min(22vw,100px))}
    .card{width:min(22vw,100px);height:min(22vw,100px)}
    #pad{right:10px;bottom:10px;grid-template-columns:56px 56px 56px;grid-template-rows:56px 56px 56px;gap:6px}
    .padBtn{border-radius:14px;font-size:1.1rem}
  }
</style>
</head>
<body>
  <!-- Tap to Start overlay -->
  <div id="tapOverlay" style="display:none;">
    <div>üíñ Tap to Start üíñ</div>
    <button id="startBtn">Start</button>
  </div>

  <!-- Intro video overlay (not skippable; fits screen; plays once per visit) -->
  <div id="introVideoOverlay" style="display:none;">
    <video id="introVideo" playsinline webkit-playsinline preload="auto">
      <source src="1000044863.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
  </div>

  <h1>Happy babii-versary‚ù§Ô∏è</h1>
  <p id="subtitle">Two games, two hearts. Beat both to unlock a surprise.</p>

  <div id="progressTracker">Progress: Memory Match üñ§ | Maze üñ§</div>

  <div id="gameSelection" class="row">
    <button class="btn" id="btnMemory">Play Memory Match üé¥</button>
    <button class="btn" id="btnMaze">Play Maze üåÄ</button>
  </div>

  <!-- Memory -->
  <section id="memoryGame" class="game-container panel" aria-labelledby="memTitle">
    <p class="title" id="memTitle">Find all the matching pairs! üê±üê±</p>
    <div id="memoryBoard" aria-label="Memory board"></div>
    <div class="row" style="margin-top:10px">
      <button class="btn" id="memRestart">Restart</button>
      <button class="btn" id="memBack">Back to Menu</button>
    </div>
  </section>

  <!-- Maze -->
  <section id="mazeGame" class="game-container panel" aria-labelledby="mazeTitle">
    <p class="title" id="mazeTitle">Guide the ü¶ñ to the üèÅ. Arrow keys or D-Pad.</p>
    <div id="mazeWrap">
      <canvas id="mazeCanvas" width="880" height="880" aria-label="Maze canvas" role="img"></canvas>
    </div>
    <div id="mazeControls" class="row">
      <button class="btn" id="mazeNew">New Maze</button>
      <button class="btn" id="mazeReset">Restart Position</button>
      <button class="btn" id="mazeBack">Back to Menu</button>
    </div>
  </section>

  <div class="win-message" id="winMessage" style="display:none;margin-top:14px">üéâ You beat both games! üéâ</div>

  <!-- D-Pad -->
  <div id="pad" aria-hidden="false">
    <div class="padBtn blank"></div>
    <button id="padUp" class="padBtn" aria-label="Up">‚ñ≤</button>
    <div class="padBtn blank"></div>
    <button id="padLeft" class="padBtn" aria-label="Left">‚óÄ</button>
    <div class="padBtn blank"></div>
    <button id="padRight" class="padBtn" aria-label="Right">‚ñ∂</button>
    <div class="padBtn blank"></div>
    <button id="padDown" class="padBtn" aria-label="Down">‚ñº</button>
    <div class="padBtn blank"></div>
  </div>

  <!-- Generic congrats modal -->
  <div id="congratsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="congratsTitle">
    <div class="modalCard">
      <div class="modalEmoji" id="congratsEmoji">üéâ</div>
      <div class="modalTitle" id="congratsTitle">Congratulations!</div>
      <p class="modalMsg" id="congratsMsg">You did it!</p>
      <div class="row">
        <button class="btn" id="congratsPrimary">OK</button>
        <button class="btn" id="congratsSecondary">Play Again</button>
      </div>
    </div>
  </div>

  <!-- Floating hearts generator -->
  <script>
    function createHeart(){
      const h=document.createElement('div'); h.className='heart'; h.textContent='üíñ';
      h.style.left = Math.random()*100 + 'vw';
      h.style.animationDuration = (5 + Math.random()*3) + 's';
      document.body.appendChild(h);
      setTimeout(()=>h.remove(),8000);
    }
    setInterval(createHeart,900);
  </script>

<script>
  /* ---------------- state & helpers ---------------- */
  let memoryWon=false, mazeWon=false;
  const progressEl = document.getElementById('progressTracker');
  function updateProgress(){
    const mem = memoryWon ? '<span class="beat">üíò</span>' : 'üñ§';
    const mz = mazeWon ? '<span class="beat">üíò</span>' : 'üñ§';
    progressEl.innerHTML = `Progress: Memory Match ${mem} | Maze ${mz}`;
    if(memoryWon && mazeWon){
      document.getElementById('winMessage').style.display='block';
    }
  }

  function showGame(id){
    document.getElementById('gameSelection').style.display='none';
    document.querySelectorAll('.game-container').forEach(el=>el.style.display='none');
    document.getElementById(id).style.display='block';
  }
  function backToMenu(){
    document.querySelectorAll('.game-container').forEach(el=>el.style.display='none');
    document.getElementById('gameSelection').style.display='flex';
  }

  /* ========== Congrats modal ========== */
  const modal = document.getElementById('congratsModal');
  const modalEmoji = document.getElementById('congratsEmoji');
  const modalTitle = document.getElementById('congratsTitle');
  const modalMsg = document.getElementById('congratsMsg');
  const modalPrimary = document.getElementById('congratsPrimary');
  const modalSecondary = document.getElementById('congratsSecondary');

  function showCongrats({emoji='üéâ',title='Congratulations!',msg='You did it!',primaryText='OK',onPrimary=()=>{},secondaryText='Play Again',onSecondary=()=>{}}={}){
    modalEmoji.textContent = emoji;
    modalTitle.textContent = title;
    modalMsg.textContent = msg;
    modalPrimary.textContent = primaryText;
    modalSecondary.textContent = secondaryText;
    modalPrimary.onclick = ()=>{ hideModal(); onPrimary(); };
    modalSecondary.onclick = ()=>{ hideModal(); onSecondary(); };
    modal.classList.add('show');
  }
  function hideModal(){ modal.classList.remove('show'); }
  modal.addEventListener('click', (e)=>{ if(e.target===modal) hideModal(); });

  /* -------- Memory Match (5 pairs = 10 cards) -------- */
  const allSymbols = ['üê±','üê∂','üê∞','üêº','ü¶ä','üêª','üê®','üêØ','ü¶Å','üêÆ','üê∑','üê∏'];
  const memoryBoard = document.getElementById('memoryBoard');
  let firstCard = null, memLock = false;

  function buildCard(sym){
    const d = document.createElement('div');
    d.className = 'card hidden';
    d.dataset.symbol = sym;
    d.textContent = sym;
    return d;
  }

  function resetMemory(){
    firstCard = null; memLock = false; memoryWon = false; updateProgress();
    memoryBoard.innerHTML = '';
    const picks = allSymbols.sort(()=>Math.random()-.5).slice(0,5); // 5 pairs
    const deck = [...picks, ...picks].sort(()=>Math.random()-.5);
    deck.forEach(sym => memoryBoard.appendChild(buildCard(sym)));
    memoryBoard.querySelectorAll('.card').forEach(card=>{
      card.onclick = ()=>{
        if(memLock || !card.classList.contains('hidden')) return;
        card.classList.remove('hidden');
        card.classList.add('revealed');
        setTimeout(()=>card.classList.remove('revealed'), 260);
        if(!firstCard){ firstCard = card; return; }
        if(firstCard.dataset.symbol === card.dataset.symbol){
          firstCard = null;
          // check win
          if([...memoryBoard.children].every(c=>!c.classList.contains('hidden'))){
            memoryWon = true; updateProgress();
            showCongrats({
              emoji:'üíñ',
              title:'Memory Master!',
              msg:'You matched all 5 pairs! Want to try the maze now?',
              primaryText:'Play Maze üåÄ',
              onPrimary: ()=> showGame('mazeGame'),
              secondaryText:'Replay Memory',
              onSecondary: ()=> resetMemory()
            });
          }
        } else {
          memLock = true;
          setTimeout(()=>{
            firstCard.classList.add('hidden');
            card.classList.add('hidden');
            firstCard = null; memLock = false;
          }, 650);
        }
      };
    });
  }

  /* -------- Maze (easier path but denser walls) -------- */
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');

  function fitCanvas(){ 
    const dpr = window.devicePixelRatio || 1;
    const r = canvas.getBoundingClientRect();
    canvas.width = Math.round(r.width * dpr);
    canvas.height = Math.round(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  new ResizeObserver(fitCanvas).observe(canvas);
  fitCanvas();

  let N = 10; // smaller grid -> shorter solution path (easier)
  const directions = [[0,-1],[1,0],[0,1],[-1,0]];
  let H, V; // horizontal/vertical walls (true = wall present)
  let start = {x:0,y:0}, goal = {x:N-1,y:N-1};

  function carveMaze(){
    // Perfect maze via DFS (start with all walls up)
    H = Array.from({length:N+1}, ()=> Array(N).fill(true));
    V = Array.from({length:N}, ()=> Array(N+1).fill(true));
    const visited = Array.from({length:N}, ()=> Array(N).fill(false));
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
    (function dfs(x,y){
      visited[y][x]=true;
      shuffle(directions.slice()).forEach(([dx,dy])=>{
        const nx=x+dx, ny=y+dy;
        if(nx>=0&&ny>=0&&nx<N&&ny<N && !visited[ny][nx]){
          if(dx===1) V[y][x+1]=false; if(dx===-1) V[y][x]=false;
          if(dy===1) H[y+1][x]=false; if(dy===-1) H[y][x]=false;
          dfs(nx,ny);
        }
      });
    })(0,0);

    // Find a shortest path from start to goal (BFS)
    const prev = Array.from({length:N}, ()=> Array(N).fill(null));
    const q=[[start.x,start.y]];
    const seen = Array.from({length:N}, ()=> Array(N).fill(false));
    seen[start.y][start.x]=true;

    while(q.length){
      const [x,y]=q.shift();
      if(x===goal.x && y===goal.y) break;
      for(const [dx,dy] of directions){
        const nx=x+dx, ny=y+dy;
        if(nx<0||ny<0||nx>=N||ny>=N) continue;
        // Can we move between (x,y) -> (nx,ny)?
        if(dx===1 && V[y][x+1]) continue;
        if(dx===-1 && V[y][x]) continue;
        if(dy===1 && H[y+1][x]) continue;
        if(dy===-1 && H[y][x]) continue;
        if(!seen[ny][nx]){
          seen[ny][nx]=true;
          prev[ny][nx]=[x,y];
          q.push([nx,ny]);
        }
      }
    }
    // Reconstruct path set
    const onPath = Array.from({length:N}, ()=> Array(N).fill(false));
    let cx=goal.x, cy=goal.y;
    onPath[cy][cx]=true;
    while(prev[cy][cx]){
      const [px,py]=prev[cy][cx];
      onPath[py][px]=true;
      cx=px; cy=py;
    }

    // Make maze look denser by closing some NON-path openings.
    // This keeps the solution path open and the puzzle solvable/easier.
    const closableEdges=[];
    // vertical openings (V[y][x] == false means opening between (x-1,y) and (x,y))
    for(let y=0;y<N;y++){
      for(let x=1;x<N;x++){
        if(!V[y][x]){ // opening
          const aX=x-1,aY=y,bX=x,bY=y;
          if(!(onPath[aY][aX] && onPath[bY][bX])){ // don't touch path edge
            closableEdges.push({type:'V', y, x});
          }
        }
      }
    }
    // horizontal openings (H[y][x] == false means opening between (x,y-1) and (x,y))
    for(let y=1;y<N;y++){
      for(let x=0;x<N;x++){
        if(!H[y][x]){
          const aX=x,aY=y-1,bX=x,bY=y;
          if(!(onPath[aY][aX] && onPath[bY][bX])){
            closableEdges.push({type:'H', y, x});
          }
        }
      }
    }
    // Close ~35% of those edges to increase visual wall density
    const target = Math.floor(closableEdges.length*0.35);
    for(let i=0;i<target;i++){
      const idx = Math.floor(Math.random()*closableEdges.length);
      const e = closableEdges.splice(idx,1)[0];
      if(e.type==='V') V[e.y][e.x]=true; else H[e.y][e.x]=true;
    }
  }

  // player & movement
  let player = {x:0,y:0,fx:0,fy:0}, moving=false, moveStart=0, fromX=0, fromY=0, toX=0, toY=0;
  const MOVE_MS = 140;

  function canMove(dx,dy){
    const nx=player.x+dx, ny=player.y+dy;
    if(nx<0||ny<0||nx>=N||ny>=N) return false;
    if(dx===1 && V[player.y][player.x+1]) return false;
    if(dx===-1 && V[player.y][player.x]) return false;
    if(dy===1 && H[player.y+1][player.x]) return false;
    if(dy===-1 && H[player.y][player.x]) return false;
    return true;
  }
  function tryMove(dx,dy){
    if(moving || mazeWon) return;
    if(!canMove(dx,dy)) return;
    const nx=player.x+dx, ny=player.y+dy;
    moving=true; moveStart=performance.now();
    fromX=player.x; fromY=player.y; toX=nx; toY=ny;
    player.x=nx; player.y=ny;
    if(navigator.vibrate) navigator.vibrate(12);
  }

  function drawMaze(){
    const cs = canvas.getBoundingClientRect().width / N;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.lineWidth = Math.max(2, Math.floor(cs*0.05)); ctx.strokeStyle = '#8b0000';
    ctx.beginPath();
    ctx.rect(0,0,N*cs,N*cs);
    for(let y=0;y<=N;y++){
      for(let x=0;x<N;x++){ if(H[y][x]){ ctx.moveTo(x*cs,y*cs); ctx.lineTo((x+1)*cs,y*cs); } }
    }
    for(let y=0;y<N;y++){
      for(let x=0;x<=N;x++){ if(V[y][x]){ ctx.moveTo(x*cs,y*cs); ctx.lineTo(x*cs,(y+1)*cs); } }
    }
    ctx.stroke();

    // goal
    ctx.font = `${Math.floor(cs*0.6)}px system-ui, 'Apple Color Emoji','Segoe UI Emoji'`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('üèÅ', goal.x*cs + cs/2, goal.y*cs + cs/2);

    // player (smooth)
    const px = player.fx*cs + cs/2;
    const py = player.fy*cs + cs/2 + (moving ? Math.sin(performance.now()/90)*cs*0.06 : 0);
    ctx.fillText('ü¶ñ', px, py);
  }

  function step(now){
    if(moving){
      const t=Math.min(1,(now-moveStart)/MOVE_MS);
      const e = t<.5 ? 2*t*t : -1+(4-2*t)*t;
      player.fx = fromX + (toX-fromX)*e;
      player.fy = fromY + (toY-fromY)*e;
      if(t>=1){ moving=false; player.fx=player.x; player.fy=player.y; afterArrive(); }
    }
    drawMaze();
    requestAnimationFrame(step);
  }

  function afterArrive(){
    if(player.x===goal.x && player.y===goal.y){
      mazeWon=true; updateProgress();
      showCongrats({
        emoji:'üö©', title:'Maze Conquered!', msg:'You found the goal! Try a new layout or replay.',
        primaryText:'New Maze', onPrimary:()=> newMaze(),
        secondaryText:'Back to Menu', onSecondary:()=> backToMenu()
      });
    }
  }

  function resetMaze(){ player={x:start.x,y:start.y,fx:start.x,fy:start.y}; mazeWon=false; updateProgress(); drawMaze(); }

  function newMaze(){
    carveMaze();
    start={x:0,y:0}; goal={x:N-1,y:N-1};
    resetMaze();
  }

  /* Keyboard & D-Pad */
  document.addEventListener('keydown',(e)=>{
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) e.preventDefault();
    if(e.key==='ArrowUp' || e.key==='w' || e.key==='W') tryMove(0,-1);
    if(e.key==='ArrowDown' || e.key==='s' || e.key==='S') tryMove(0,1);
    if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') tryMove(-1,0);
    if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') tryMove(1,0);
  });

  function pad(el,dx,dy){
    const fire = ()=> tryMove(dx,dy);
    el.addEventListener('click',fire);
    el.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); fire(); }, {passive:false});
  }
  pad(document.getElementById('padUp'),0,-1);
  pad(document.getElementById('padDown'),0,1);
  pad(document.getElementById('padLeft'),-1,0);
  pad(document.getElementById('padRight'),1,0);

  /* init */
  newMaze();
  requestAnimationFrame(step);

  /* ========== UI wiring ========== */
  // menu buttons
  document.getElementById('btnMemory').onclick = ()=> showGame('memoryGame');
  document.getElementById('btnMaze').onclick = ()=> showGame('mazeGame');
  document.getElementById('memBack').onclick = backToMenu;
  document.getElementById('memRestart').onclick = resetMemory;
  document.getElementById('mazeBack').onclick = backToMenu;
  document.getElementById('mazeNew').onclick = newMaze;
  document.getElementById('mazeReset').onclick = resetMaze;

  /* Initialize memory board */
  resetMemory();
</script>

<!-- === One-time splash logic (audio-safe on mobile) === -->
<script>
  const tapOverlay = document.getElementById('tapOverlay');
  const introOverlay = document.getElementById('introVideoOverlay');
  const introVideo = document.getElementById('introVideo');
  const startBtn = document.getElementById('startBtn');

  function closeIntro(){
    introOverlay.classList.add('fade-out');
    setTimeout(()=> introOverlay.remove(), 1000);
    localStorage.setItem('introPlayed', 'true');
  }

  if(!localStorage.getItem('introPlayed')){
    tapOverlay.style.display = 'flex';
    startBtn.addEventListener('click', () => {
      tapOverlay.remove();
      introOverlay.style.display = 'flex';
      // play with sound after a user gesture (mobile-friendly)
      const playPromise = introVideo.play();
      if(playPromise && typeof playPromise.then==='function'){
        playPromise.catch(()=>{/* fallback ignored; user can tap again if needed */});
      }
    });
    introVideo.addEventListener('ended', closeIntro);
  }
</script>
</body>
</html>
